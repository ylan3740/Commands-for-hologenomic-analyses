##SUPPLEMENTARY COMMANDS#Commands used in 'Hologenome analysis reveals dual symbiosis in the deep-sea hydrothermal vent snail Gigantopelta aegis' by Lan et al.# Clean the Illumina reads with Trimmomaticjava -jar trimmomatic-0.36.jar PE -phred33 input_forward.fq.gz input_reverse.fq.gz output_forward_paired.fq.gz output_forward_unpaired.fq.gz output_reverse_paired.fq.gz output_reverse_unpaired.fq.gz ILLUMINACLIP:TruSeq3-PE-2.fa:2:30:10 LEADING:3 TRAILING:3 SLIDINGWINDOW:4:15 MINLEN:36#Symbiont genome assembly pipelinesspades.py --meta -1 Gae01osg_1.fq -2 Gae01osg_2.fq -k 51,61,71,81,91 -o symbiont_assemble –t 20unicycler -1 grouped_reads_1.fq -2 grouped_reads_2.fq -l nanopore_reads.fastq -o output_dirperl ~/software/SSPACE-LongRead_v1-1/SSPACE-LongRead.pl -c mob.fa -p all_ont_pb_10k.fasta -t 24 -b mob_scaffolding_ALLont_pb_symbiont_10kperl run_MaxBin.pl -contig Ga01osg_contig -reads Ga01osg_1_paired.fq -reads2 Ga01osg_2_paired.fq -out Ga01osg_out -thread 20## Gene prediction of symbiont genomeprodigal -i symbiont_genome.fa -a symbiont_protein.fa -d symbiont_cds.fa##Quality check of symbiont genomes with CheckMcheckm lineage_wf bin/ checkm_output -x fasta# Genome survey using kmer distribution generated by the Illumina reads with Platanus v1.2.4platanus assemble -o Gae -f Gae_Illumina_paired_1.fq Gae_Illumina_paired_2.fq -k 17 -t 30 -m 320# correct and trim the pacbio reads with canucanu -p gi_aegis_4k -d gi_aegis_4k genomeSize=1.27g corMhapSensitivity=normal corMinCoverage=0 -pacbio-raw gae_pacbio_4k.fasta corMaxEvidenceErate=0.15 correctedErrorRate=0.065 minReadLength=8000 maxThreads=80# assemble the genome with canu trimmed reads using smartdenovo and wtdbg2smartdenovo.pl -t 40 -c 1 -p smartdenovo trimmedReads.fasta > assembly.makmake -f assembly.mak wtdbg2 -i pacbio_corrected_reads.fa -e 2 --tidy-reads 5000 -S 1 -k 15 -p 0 --rescue-low-cov-edges --aln-noskip -o assembly.fa# minimap + miniasm assemblyminimap2 -X -t 10 -x ava-pb pacbio.fasta pacbio.fasta | gzip -1 > reads.paf.gzminiasm -f pacbio.fasta reads.paf > Gae_default.gfaawk '/^S/{print ">"$2"\n"$3}' Gae_default.gfa | fold > Gae_assembly.fa# Hybrid assemling with masurca /masurca configuration.txt ./assemble.sh# use Racon to polish the genomeminimap2 -t 90 -x map-pb Gae_miniasm_redunO0.7_0.9.fa Raw_subreads.fa > reads.pafminimap2 -ax map-pb -t 20 Gae_9k_smartdenovo_contig.fa all_pacbio_9k.fasta | samtools view -bS - | samtools sort - > reads_sorted.bamperl -pi -e 's/m(.*?)M::(.*?)\n//g' reads_2.pafperl -pi -e 's/\[M(.*?)sequences\n//g' reads_2.pafracon -t 12 -1 Raw_subreads.fa reads.paf Gae_miniasm_redunO0.7_0.9.fa Gae_miniasm_redunO0.7_0.9_racon1.faminimap2 -t 20 -x map-pb Gae_miniasm_redunO0.7_0.9_racon1.fa all_pacbio_9k.fasta > ref_reads_mapping_2.pafracon -t 20 all_pacbio_9k.fasta ref_reads_mapping_2.paf Gae_miniasm_redunO0.7_0.9_racon1.fa > Gae_miniasm_redunO0.7_0.9_racon2.fa# pilon error correction with Illumina readsbowtie2-build Gae_miniasm_redunO0.7_0.9_racon2.fa Gae_miniasm_redunO0.7_0.9_racon2.fabowtie2 -p 10 -x Gae_miniasm_redunO0.7_0.9_racon2.fa -1 Ga01_350bp_1_paired_fastuniq.fq -2 Ga01_350bp_2_paired_fastuniq.fq | samtools view -bS - > racon2fa_illumina.bamsamtools sort racon2fa_illumina.bam –o racon2fa_illumina.sortedsamtools index racon2fa_illumina.sorted.bamjava -Xmx300G -jar pilon-1.22.jar --genome Gae_miniasm_redunO0.7_0.9_racon2.fa --frags racon2fa_illumina.sorted.bam --output Gae_racon2_pilon --outdir Gae --diploid --threads 20################ using BUSCO to check the genome completenesspython BUSCO.py -i Gae_chr.fa -o Gae_busco -l metazoa_odb9 -m geno -t tmp# using HiCpro to assess the quality of HiC library digest_genome.py -r mboi -o gae_mobI.bed Gae_contig.fabowtie2-build --threads 40 Gae_contig.fa GaeHiC-Pro -c config.txt -I fastq2 -o two -s mapping -s proc_hic -s quality_checks### processing the HiC valid reads by Juicer pipeline # index the referencefaSize -detailed Gae_contig.fa > gae_size.txtbwa index Gae_contig.fa~/GitHub/juicer/misc/generate_site_positions.py "MboI" "gae" Gae_contig.fash juicer.sh -y gae_MboI.txt -z Gae_contig.fa -p gae_size.txt -t 20# genomic scaffolding with 3D de novo assembly pipelinerun-asm-pipeline.sh -m diploid -s finalize -r 1 Gae_contig.fa merged_nodups.txt# de novo transcriptome assembly by TrinityTrinity -seqType fq --max_memory 300G --left Gae_RNA_total_1.fq --right Gae_RNA_total_2.fq --CPU 20 &cd-hit-est -i Trinity.fasta -o Trinity_cdhit0.95.fasta -c 0.95 -T 24# genome guided transcriptome assembly by Trinitybowtie2-build Gae_contig.fa Gae_contig.fabowtie2 -p 10 -x Gae_contig.fa -1 Ga01_illumina_1.fq -2 Ga01_illumina.fq | samtools view -bS - > Gae.bamsamtools sort Gae.bam -o Gae.sorted.bamsamtools index Gae.sorted.bamTrinity --genome_guided_bam accepted_hits.bam --max_memory 350G -genome_guided_max_intron 150000 --CPU 38 --normalize_reads --min_contig_length 250## using PASA to build a comprehensive transcriptome database, combining the de novo assembly and genome-guided assembly.cat Trinity.fasta Trinity-GG.fasta >Trinity_all_new.fastaseqclean Trinity_all_new.fasta -c 8seqclean Trinity.fasta -c 8perl accession_extractor.pl < Trinity.fasta.clean >tdn.accsperl Launch_PASA_pipeline.pl -c alignAssembly.config -C -R -g Gae_contig.fa -t Trinity_all_new.fasta.clean -T -u Trinity_all_new.fasta --TDN tdn.accs --ALIGNERS gmap,blat --CPU 4 --annots_gff3 Gae_maker_transcripts.gff --stringent_alignment_overlap 30.0 --gene_overlap 50.0build_comprehensive_transcriptome.dbi -c alignAssembly.config -t Trinity_all_new.fasta.clean --min_per_ID 95 --min_per_aligned 30# RepeatModeler:~/RepeatModeler/BuildDatabase -name Gae_repeats Gae_contig.fa~/RepeatModeler/RepeatModeler -database Gae_repeats -pa 48#RepeatMaskerRepeatMasker -lib consensi.fa.classified -pa 40 -div 30 Gae_contig.faRepeatMasker -species all -pa 40 -div 30 Gae_contig.fa.masked# how to train Augustus gene predictor#Augustus:perl gff2gbSmallDNA.pl Gae.gff Gae_contig.fasta.masked.masked 1000 Gae_augustus_v01perl new_species.pl --species Gigantopeltaetraining --species=Gigantopelta Gae_augustus_v01 --/genbank/verbosity=2perl gff2gbSmallDNA.pl Gae.gff Gae_contig.fasta.masked.masked 1000 Gae_augustus_v01 --bad=blackList.txtetraining --species=Gigantopelta Gae_augustus_v01 --/genbank/verbosity=2perl optimize_augustus.pl --cpus=40 --species= Gigantopelta Gae_augustus_v02etraining --species= Gigantopelta Gae_augustus_v03# maker annotation fasta_tool --chunks 20 Gae_v1.0.fastamaker -base Gae_v1.0 -g Gae_contig.fasta.maskedgff3_merge -l -d Gae_master_datastore_index.log -o Gae.gfffasta_merge -d Gae_master_datastore_index.log -o Gae# blast the whole NCBI nr databaseblastp -num_threads 96 -query Gae_proteins.fa -db nr_database -out Gae_Blastp.m5 -outfmt 5 -evalue 1e-5 -max_target_seqs 5 # hmmscan the Pfam databasehmmscan --tblout high_expression_50.pfam -E 1 --cpu 1 /home/jin/db/Pfam/Pfam-A.hmm high_expression_50.fasta# using Kallisto to quantify the gene expressionkallisto index sob.cds.fa -i 1kallisto quant -i sob.cds.index -t 96 Ga01RNA_1_paired.fq Ga01RNA_2_paired.fq -o Ga01_quant# gene expression analysis using edgeRperl ~/trinityrnaseq-Trinity-v2.3.2/Analysis/DifferentialExpression/run_DE_analysis.pl --matrix mantle_gill_matrix.txt --method edgeR --dispersion 0.1# Assign the orthologue genes by Orthofinderpython orthofinder.py -f all_protein_seq/ -t 288 -a 288 -S blast -M msa# Synteny analysisMCScanX ./xyz# phylogenetic analysis with iqtreeiqtree -s c_Lectin.ali.fasta -st AA -m LG+I+G4+F -bb 1000 -alrt 1000 -nt 4## Calibrate the tree with time constrains, estimate the divergent time by MCMCTreecodeml codeml.ctl# first round: in the mcmctree.ctl, change usedata = 3, and outfile = out_usedata3# second round: change the file name "out.BV" to  "in.BV"; change usedata = 2, and outfile = out_usedata2~/App/PAML_4.8/mcmctree mcmctree.ctl# the tree file with time constrains used in MCMCTree analysis20 1
(((Eup,Oct),((((Bpl,Mph),(Cgi,Pfu)),(Cfa,Pye))'L(4.65, 0.1, 1.0, 1e-300)',((((Csq,(Gae,dsu)),Hal),Lot),((Lan,(Mco,Pca))'U(1.50, 0.1, 1.0, 1e-300)',(Apl,Rau)'B(1.686, 4.734, 1e-300, 0.1)')'L(3.90, 0.1, 1.0, 1e-300)')'B(4.702, 5.315, 1e-300, 0.1)'))'B(5.32, 5.49, 1e-300, 0.1)',(Lin2,Pau))'B(5.5025, 6.361, 1e-300, 1e-300)';############### the mcmctree.ctl file        seed = -1       seqfile = SpeciesTreeAlignment.phy      treefile = Raxml_GAE_fossils_2.nwk       outfile = out_usedata2       seqtype = 2         ndata = 1       usedata = 2    * 0: no data; 1:seq like; 2:normal approximation         clock = 2    * 1: global clock; 2: independent rates; 3: correlated rates       RootAge = '<10'  * constraint on root age, used if no fossil for root.         model = 3                   * models for codons:                       * 0:one, 1:b, 2:2 or more dN/dS ratios for branches                   * models for AAs or codon-translated AAs:                       * 0:poisson, 1:proportional, 2:Empirical, 3:Empirical+F                       * 6:FromCodon, 7:AAClasses, 8:REVaa_0, 9:REVaa(nr=189)    aaRatefile = lg.dat  * only used for aa seqs with model=empirical(_F)                   * dayhoff.dat, jones.dat, wag.dat, mtmam.dat, or your own         alpha = 0.5         ncatG = 5     cleandata = 1    * remove sites with ambiguity data (1:yes, 0:no)?       BDparas = 1 1 0   * birth, death, sampling   kappa_gamma = 6 2      * gamma prior for kappa   alpha_gamma = 1 1      * gamma prior for alpha   rgene_gamma = 1 18.87     * gamma prior for rate for genes  sigma2_gamma = 1 4.5    * gamma prior for sigma^2     (for clock=2 or 3)      finetune = 1: 0.057  0.25  0.008  0.12 0.3  * times, rates, mixing, paras, RateParas         print = 1        burnin = 10000000      sampfreq = 1000       nsample = 10000##################### using CAFE for the gene family analysiscafe cafe.sh#in cafe.sh#!/home/share/CAFE/release/cafeversiondateload -i orthoMCL2cafe.tab -t 20 -l log.txt -p 0.05tree ((Pau:4.721745,Lin2:4.721745):1.201393,((Eup:2.401588,Oct:2.401588):3.121494,(((Pye:0.334293,Cfa:0.334293):4.380509,((Pfu:3.302425,Cgi:3.302425):1.015206,(Bpl:1.045217,Mph:1.045217):3.272414):0.397171):0.615562,((Lot:4.485623,(Hal:3.794268,(Gae:1.179382,Csq:1.179382):2.614886):0.691355):0.335298,((Apl:2.046399,Rau:2.046399):2.053567,(Lan:1.004142,(Pca:0.328417,Mco:0.328417):0.675725):3.095824):0.720954):0.509444):0.192717):0.400057);lambda -s -t ((1,1)1,((1,1)1,(((1,1)1,((1,1)1,(1,1)1)1)1,((1,(1,(1,1)1)1)1,((1,1)1,(1(1,1)1)1)1)1)1)1);report out############# the Rscript for the circos plot of Gigantopelta aegislibrary(seqinr)library(circlize)library(dplyr)library(ggplot2)dnaseq = read.fasta(file="./gae_hic_update.fasta",as.string=TRUE)lapply(dnaseq, length)### unused# Moving window along the sequence:## globe variablesstep <- 50000wsize <- 100000run_gc_abs<-function(dnaseq){  starts <- seq(from = 1, to = nchar(dnaseq), by = step)  starts <- starts[-length(starts)]  chro=as.character(attributes(dnaseq)$name)    n <- length(starts)  df = data.frame(matrix(NA, ncol=4, nrow=n))  colnames(df)=c("chro", "start", "end", "fraction")  for (i in seq_len(n)) {    result <- GC( s2c(substr(dnaseq, starts[i], starts[i] + wsize - 1)) )    df[i,]<-c(chro,starts[i], starts[i] + wsize - 1, result)  }  return(df)}run_get_length<-function(dnaseq){  chro=as.character(attributes(dnaseq)$name)  len_one=getLength(dnaseq)    df = data.frame(matrix(NA, ncol=3, nrow=1))  colnames(df)=c("chro", "start", "end")  df[1, ]<-c(chro, 1, len_one)  return(df)}## test one tmp=run_gc_abs(dnaseq[[1]])tmp=run_get_length(dnaseq[[1]])### run apply for all and output a dflist_merge<-function(gc_l){  gc_all=gc_l[[1]]  for (i in 2:length(gc_l)){    gc_all=rbind(gc_all, gc_l[[i]])  }  return(gc_all)}### gc content run codegc_l=lapply(dnaseq, run_gc_abs)bed_gc=list_merge(gc_l)# redeine the df type as numericbed_gc$start=as.numeric(bed_gc$start)bed_gc$end=as.numeric(bed_gc$end)bed_gc$fraction=as.numeric(bed_gc$fraction)bed_gc<-filter(bed_gc, fraction!="NA")# change to the dev instead of meanbed_gc$fraction=bed_gc$fraction-mean(bed_gc$fraction, na.rm =T) #0.4525953### len run codelen_l=lapply(dnaseq, run_get_length)bed_len=list_merge(len_l)bed_len$start=as.numeric(bed_len$start)bed_len$end=as.numeric(bed_len$end)# store the datawrite.csv(bed_len, "bed_len.csv")write.csv(bed_gc, "bed_gc.csv")bed_len=filter(bed_len, grepl('chr', chro))### merge the cog with gene position from gffgene=read.csv("Gae_update.gff.csv", header = F, comment.char = "#")gene_cog=read.csv("KOG.csv", header = F)colnames(gene_cog)=c("gene", "cog")cog_col=read.csv("cog_color.csv", header = T)gene_color=merge(gene_cog, cog_col, by="cog")cg_high=read.csv("osg_high_expression.csv", sep=",", header = F)cg_high=filter(gene, V5 %in% cg_high$V1)gene=merge(gene, gene_color, by.x="V5", by.y="gene")[2:7]### plot codepdf(width=6, height=6)circos.clear()circos.par("start.degree" = 90)circos.initializeWithIdeogram(bed_len, sort.chr = TRUE,plotType = c("axis", "labels"))#circos.yaxis(labels.cex = 0.1, side=("right"))circos.genomicTrack(bed_gc, track.height = 0.1125,                    panel.fun = function(region, value, ...) {                      circos.genomicRect(region, value, ytop.column = 1, ybottom = 0, ylim=c(-0.04, 0.04),                                         border =NA,                                         col = ifelse(value[[1]] > 0, "#335ba5", "#35b8e9"), ...)                    })#circos.yaxis(labels.cex = 0.1, side=("right"))circos.genomicDensity(cg_high,col = c("#d8b365"), window.size = 2500000, track.height = 0.1125 )circos.genomicDensity(gene,col = c("#999999"), window.size = 2500000, track.height = 0.1125 )dev.off()######################### the Rscript for the circos plot of Gigantopelta aegis symbiontslibrary(seqinr)library(circlize)library(dplyr)library(ggplot2)dnaseq = read.fasta(file="./mob_10.fa",as.string=TRUE)lapply(dnaseq, length)gcskew <- function(x) {  if (!is.character(x) || length(x) > 1)    stop("single string expected")  tmp <- tolower(s2c(x))  nC <- sum(tmp == "c")  nG <- sum(tmp == "g")  if (nC + nG == 0)    return(NA)  return(100 * (nC - nG)/(nC + nG))}## Moving window along the sequence:## globe variablesstep <- 2500wsize <- 5000run_gcskew<- function(dnaseq){  starts <- seq(from = 1, to = nchar(dnaseq), by = step)  starts <- starts[-length(starts)]    chro=as.character(attributes(dnaseq)$name)    n <- length(starts)  df = data.frame(matrix(NA, ncol=4, nrow=n))  colnames(df)=c("chro", "start", "end", "fraction")  for (i in seq_len(n)) {    result<- gcskew(substr(dnaseq, starts[i], starts[i] + wsize - 1))    df[i,]<-c(chro,starts[i], starts[i] + wsize - 1, result)  }  return(df)}run_gc_abs<-function(dnaseq){  starts <- seq(from = 1, to = nchar(dnaseq), by = step)  starts <- starts[-length(starts)]  chro=as.character(attributes(dnaseq)$name)    n <- length(starts)  df = data.frame(matrix(NA, ncol=4, nrow=n))  colnames(df)=c("chro", "start", "end", "fraction")  for (i in seq_len(n)) {    result <- GC( s2c(substr(dnaseq, starts[i], starts[i] + wsize - 1)) )    df[i,]<-c(chro,starts[i], starts[i] + wsize - 1, result)  }  return(df)}run_get_length<-function(dnaseq){  chro=as.character(attributes(dnaseq)$name)  len_one=getLength(dnaseq)    df = data.frame(matrix(NA, ncol=3, nrow=1))  colnames(df)=c("chro", "start", "end")  df[1, ]<-c(chro, 1, len_one)  return(df)}## test one tmp=run_gcskew(dnaseq[[1]])tmp=run_gc_abs(dnaseq[[1]])tmp=run_get_length(dnaseq[[1]])### run apply for all and output a dfgcsk_l=lapply(dnaseq, run_gcskew)list_merge<-function(gc_l){  gc_all=gc_l[[1]]  for (i in 2:length(gc_l)){    gc_all=rbind(gc_all, gc_l[[i]])  }  return(gc_all)}bed_gcsk=list_merge(gcsk_l)# redeine the df type as numericbed_gcsk$start=as.numeric(bed_gcsk$start)bed_gcsk$end=as.numeric(bed_gcsk$end)bed_gcsk$fraction=as.numeric(bed_gcsk$fraction)bed_gcsk<-filter(bed_gcsk, fraction!="NA")### gc content run codegc_l=lapply(dnaseq, run_gc_abs)bed_gc=list_merge(gc_l)# redeine the df type as numericbed_gc$start=as.numeric(bed_gc$start)bed_gc$end=as.numeric(bed_gc$end)bed_gc$fraction=as.numeric(bed_gc$fraction)bed_gc<-filter(bed_gc, fraction!="NA")# change to the dev instead of meanbed_gc$fraction=bed_gc$fraction-mean(bed_gc$fraction, na.rm =T) #0.4525953### len run codelen_l=lapply(dnaseq, run_get_length)bed_len=list_merge(len_l)bed_len$start=as.numeric(bed_len$start)bed_len$end=as.numeric(bed_len$end)# store the datawrite.csv(bed_len, "bed_len.csv")write.csv(bed_gc, "bed_gc.csv")write.csv(bed_gcsk, "bed_gcsk.csv")### merge the cog with gene position from gffgene=read.csv("mob_genebed.csv", header = F, comment.char = "#")gene_cog=read.csv("mob_cog.csv", header = T)cog_col=read.csv("cog_color.csv", header = T)gene_color=merge(gene_cog, cog_col, by="cog")gene=merge(gene, gene_color, by.x="V5", by.y="gene")[2:7]# plot the color huepdf("color.pdf", width=12, height=3)ggplot(cog_col, aes(x = cog, y = 1, fill = color)) +  geom_tile() +  geom_text(aes(label = cog)) +  scale_fill_identity()+theme_bw()dev.off()### plot codecircos.clear()circos.par("start.degree" = 90)circos.initializeWithIdeogram(bed_len, sort.chr = FALSE,plotType = c("axis", "labels"))circos.genomicTrack(gene,track.height = 0.08,                    panel.fun = function(region, value, ...) {                      circos.genomicRect(region, value, value$V5, ytop.column = 1, ybottom = 0,                                         col=value$color, border =NA, ...)                    })#circos.yaxis(labels.cex = 0.1, side=("right"))circos.genomicTrack(bed_gc, track.height = 0.25,                    panel.fun = function(region, value, ...) {                      circos.genomicRect(region, value, ytop.column = 1, ybottom = 0,                                         border =NA,                                         col = ifelse(value[[1]] > 0, "#335ba5", "#35b8e9"), ...)                    })circos.yaxis(labels.cex = 0.1, side=("right"))circos.genomicTrack(bed_gcsk, track.height = 0.25,                    panel.fun = function(region, value, ...) {                      circos.genomicRect(region, value, ytop.column = 1, ybottom = 0,                                         border =NA,                                         col = ifelse(value[[1]] > 0, "#bb86b9", "#71bd4e"), ...)                    })circos.yaxis(labels.cex = 0.1, side=("right"))################################ Symbiont Genome Binning  #####################################################


##### Step I: quality control, clean reads
java -jar trimmomatic-0.36.jar PE -phred33 Gae01osg_1.fq.gz Gae01osg_2.fq.gz Gae01osg_1_paired.fq Gae01osg_1_unpaired.fq Gae01osg_2_paired.fq Gae01osg_2_unpaired.fq ILLUMINACLIP:TruSeq3-PE-2.fa:2:30:10 LEADING:3 TRAILING:3 SLIDINGWINDOW:4:15 MINLEN:36
##### Step II: Illumina data file, assembly by SPAdes
spades.py --meta -1 Gae01osg_1_paired.fq -2 Gae01osg_2_paired.fq -k 51,61,71,81,91 -o symbiont_assemble –t 20

##### Step III: filter out contigs, which is less than 1000 bp and rename the left contigs as 1, 2, 3, ...
perl $BinScriptDir/lgth_cutf_1000.pl contigs.fasta assembly.fa;
cp assembly.fa.num assembly.fa;

##### Step IV: GC and Tetranucleotide calculation
perl $BinScriptDir/calc.gc.pl -i assembly.fa -o assembly.gc.tab
perl $BinScriptDir/calc.kmerfreq.pl -i assembly.fa -o assembly.kmer.tab

##### Step V: coverage anaylsis, using bowite2 and samtools
mkdir Bowtie2
cd Bowtie2
bowtie2-build -f ../assembly.fa assembly
bowtie2 -q -x assembly -1 $fq11,$fq21 -2 $fq12,$fq22 -S Illu_qc_1.sam -p 4
samtools view -bS Illu_qc_1.sam >Illu_qc_1.bam
samtools sort Illu_qc_1.bam > Illu_qc_1.sorted.bam
samtools depth Illu_qc_1.sorted.bam >Illu_qc_1.depth
perl $BinScriptDir/coverage_sum.pl Illu_qc_1.depth Illu_qc_1.cov
perl $BinScriptDir/coverage_length.pl Illu_qc_1.cov ../assembly.fa HPminus.scaffold.coverage.csv
cp HPminus.scaffold.coverage.csv ../
rm -rf *.sam *.bam
cd ..

##### Step VI: Identification of conserved marker proteins
mkdir Conserved_pro
cd Conserved_pro
prodigal -a temp.orfs.faa -i ../assembly.fa -m -o temp.txt -p meta -q
cut -f 1 -d " " temp.orfs.faa >assembly.orfs.faa
hmmsearch --tblout assembly.hmm.orfs.txt --cut_tc --notextw $BinScriptDir/essential.hmm assembly.orfs.faa
tail -n+4 assembly.hmm.orfs.txt |sed 's/ * / /g' |cut -f1,4 -d " " |sed 's/_/ /'>assembly.orfs.hmm.id.txt
grep -v "#" assembly.hmm.orfs.txt | cut -f1 -d " " > list.of.positive.orfs.txt
perl $BinScriptDir/extract.using.header.list.pl -l list.of.positive.orfs.txt -s assembly.orfs.faa -o assembly.orfs.hmm.faa
blastp -query assembly.orfs.hmm.faa -db /home/share/db/ncbi_nr_20161219/nr -evalue 1e-5 -num_threads 8 -max_target_seqs 50 -outfmt 5 -out assembly.orfs.hmm.blast.xml##### Step VII: MEGAN
MEGAN +g -x "import blastfile= assembly.orfs.hmm.blast.xml meganfile=temp.rma;recompute toppercent=5;recompute minsupport=1;update;collapse rank=Species;update;select nodes=all;export what=CSV format=readname_taxonpath separator=tab file=assembly.orfs.hmm.blast.tax.txt;update;close";##### Step VIII: Finding essential genes - Extracting consensus taxonomic assignment
perl $BinScriptDir/hmm.majority.vote.pl -i assembly.orfs.hmm.blast.tax.txt -o assembly.tax.consensus.txt -n
sed 's/\t/;/' assembly.orfs.hmm.blast.tax.txt | cut -f1,5 -d ";" | sed 's/;/\t/' | sed 's/_/\t/'  > assembly.orfs.hmm.blast.tax.tab

#### The final files you need
# assembly.fa
# assembly.gc.tab
# assembly.kmer.tab
# assembly.orfs.hmm.blast.tax.tab
# assembly.orfs.hmm.id.txt
# assembly.tax.consensus.txt
# HPminus.scaffold.coverage.csv
# metagenome.workflow.R     #copy from ~/scripts/meta_binning/
# metagenome.workflow.Rproj #copy from ~/scripts/meta_binning/

#cp ~/scripts/meta_binning/metagenome.workflow.modified.R R
#Run metagenome.workflow.R with R script in Windows/macOS to extract the draft genome
